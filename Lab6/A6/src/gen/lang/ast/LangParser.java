package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short LPAR = 2;
		static public final short NUMERAL = 3;
		static public final short RBRA = 4;
		static public final short INT = 5;
		static public final short RPAR = 6;
		static public final short ADD = 7;
		static public final short SUB = 8;
		static public final short IF = 9;
		static public final short WHILE = 10;
		static public final short SEMICOLON = 11;
		static public final short RETURN = 12;
		static public final short LBRA = 13;
		static public final short ASSIGN = 14;
		static public final short COMMA = 15;
		static public final short MOD = 16;
		static public final short DIV = 17;
		static public final short MUL = 18;
		static public final short ELSE = 19;
		static public final short LE = 20;
		static public final short GE = 21;
		static public final short LEQ = 22;
		static public final short GEQ = 23;
		static public final short NOT = 24;
		static public final short EQUALS = 25;

		static public final String[] NAMES = {
			"EOF",
			"ID",
			"LPAR",
			"NUMERAL",
			"RBRA",
			"INT",
			"RPAR",
			"ADD",
			"SUB",
			"IF",
			"WHILE",
			"SEMICOLON",
			"RETURN",
			"LBRA",
			"ASSIGN",
			"COMMA",
			"MOD",
			"DIV",
			"MUL",
			"ELSE",
			"LE",
			"GE",
			"LEQ",
			"GEQ",
			"NOT",
			"EQUALS"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9orbbbp5KKOXjy#6qaEILGGWSG8aWMp66CqBg0eCOgYB8AWB0PaYI18nBMiihGigwpoqZl" +
		"lkEFEE#$y0#xxZWikGKK55yIzVQQdGsRwJ99AMKxozBVqEpqzFJtp7SaygTjrZIxIkUfLGO" +
		"rgrahLgaxrEasdwmnLg#mKStMP5kaABT7LWU8chpXFytInvckXpWuKjrGeMWB5RGd5EKwH3" +
		"nHteXWx$mBDKNT5l4VJT8dsgSEDbRClg9#ug2sQdXfhud7EqjtQeVE3xBL1V4CGtnp4cr9n" +
		"GofQa8ekJqMBKz6LgUYgLBIKfyRpiiSrmp#$LLg6jr4bUwmYLvEXwy$8pSp8pGvoVUIYcRI" +
		"vcKJUXSwB5UsgqZOrgLKzkjJjgDYFU#EsCZF5rbfrQa1dwdfsxImDkkjqkJQ1VKLRjLFNQR" +
		"bMw4QjrXgjHxLRQxLE6xHPj#eERTSktQKXTa#$zhBF6sIKO$yLsKrLN6i1OxKmtpPth#rEC" +
		"PChpsAdpEP9PoiY6daJcjZF$rtHDOvYzFnvh7yO5rLYZRhOoL5F3y$847SGfyUQR9nkzbhd" +
		"fAgfnVz7PDppAd3VyVEhLWtUTFpAN24ZPp9o7HcvSf0haHkRoPWNAt9yUKh#krDoCupzk3T" +
		"kApDJRSNOTSminypgQAFhrBisIHsg4geITr2BgiHRNSzVhLkFChRixguRBxh33iOTVaoZXz" +
		"de$Rrm1BQGQyGUWcE#RoIouy7n5#UiyRxXlnJvbWDp6Dw3e#GRi2U2Sz6OXL0Dyw5thC#qm" +
		"WnOv#E#H5yxB9vuNcO9R8AbC0W3i1MMmJPO3ZkyTYMiW9q#tWohOGyCaJYEtPSO#rvO2yCG" +
		"hTqVs0TXEzm31NZ8QzV3Vkz7wziCk#0#dxlVsztm0DJ18pxtgBTFPApx8cZo$e2t6$pQZoH" +
		"qgoPU9nrA#4D1tzFUrdZR6VG$uss3dwS9vvZm1zDzyJwPO5u7l3texRFUFkVjyu5#Vn0$FE" +
		"gp7YSpndyyuLS5VNCI$bD1N$yaysvFtAD$B#BtBA4PZetzMud3yYRPx#rtzgZzrdvZlxP7N" +
		"FQmQp#p7z1#2k$3E$OD#xe$Y$VBlcrVfJ96qMzmmlvYtyM#PL#qBzitxKdxgtsD#1Fu67Yx" +
		"xKVmeNt9Zp6IciUNzeTK$8MtdxlsgrDvThtz$LJq9$m4FzgVxJya#bnzwd7ag5hJe8hgL8G" +
		"2NzE8FBNBG9vwPAXA4Nc#LZdgeS1G5IDoL3YJIJFZj75E2#EtEihKmZmKgL7vSJ1Kbxp7K6" +
		"lo2GnV#r7opaQ$7#QwhwUX3XZr$WixTb1A");

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = func_list.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Program(a);
				}
			},
			new Action() {	// [1] func_list = func.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Func a = (Func) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [2] func_list = func_list.a func.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Func b = (Func) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [3] func = INT id_decl.id LPAR RPAR LBRA opt_stmt_list.b RBRA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final StmtBlock b = (StmtBlock) _symbol_b.value;
					 return new Func(id, new List(),b);
				}
			},
			new Action() {	// [4] func = INT id_decl.id LPAR param_decl_list.a RPAR LBRA opt_stmt_list.b RBRA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 7];
					final StmtBlock b = (StmtBlock) _symbol_b.value;
					 return new Func(id, a, b);
				}
			},
			new Action() {	// [5] funcCall = id_use.a LPAR call_param_list.b RPAR SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUse a = (IdUse) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new FuncCallStmt(new FuncCall(a, b));
				}
			},
			new Action() {	// [6] funcCall = id_use.a LPAR RPAR SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUse a = (IdUse) _symbol_a.value;
					 return new FuncCallStmt(new FuncCall(a, new List()));
				}
			},
			new Action() {	// [7] nestedFuncCall = id_use.a LPAR call_param_list.b RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUse a = (IdUse) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new FuncCall(a, b);
				}
			},
			new Action() {	// [8] nestedFuncCall = id_use.a LPAR RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUse a = (IdUse) _symbol_a.value;
					 return new FuncCall(a, new List());
				}
			},
			new Action() {	// [9] call_param_list = call_param.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [10] call_param_list = call_param_list.a COMMA call_param.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [11] call_param = expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
				}
			},
			new Action() {	// [12] param_decl_list = param.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final FuncParam a = (FuncParam) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [13] param_decl_list = param_decl_list.a COMMA param.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final FuncParam b = (FuncParam) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [14] param = INT id_decl.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final IdDecl a = (IdDecl) _symbol_a.value;
					 return new FuncParam(a);
				}
			},
			new Action() {	// [15] opt_stmt_list = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new StmtBlock(new List());
				}
			},
			new Action() {	// [16] opt_stmt_list = stmt_list.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new StmtBlock(a);
				}
			},
			new Action() {	// [17] stmt_list = stmt.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Stmt a = (Stmt) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [18] stmt_list = stmt_list.a stmt.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return a.add(b);
				}
			},
			Action.RETURN,	// [19] stmt = id_decl_stmt
			Action.RETURN,	// [20] stmt = id_assign
			Action.RETURN,	// [21] stmt = whileStmt
			Action.RETURN,	// [22] stmt = ifStmt
			Action.RETURN,	// [23] stmt = return_stmt
			Action.RETURN,	// [24] stmt = funcCall
			new Action() {	// [25] id_assign = id_use_expr.a ASSIGN expr.b SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUseExpr a = (IdUseExpr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Assign(a, b);
				}
			},
			new Action() {	// [26] return_stmt = RETURN expr.a SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					  return new Return(a);
				}
			},
			new Action() {	// [27] whileStmt = WHILE LPAR expr.a RPAR LBRA opt_stmt_list.b RBRA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final StmtBlock b = (StmtBlock) _symbol_b.value;
					 return new While(a, b);
				}
			},
			new Action() {	// [28] ifStmt = IF LPAR expr.a RPAR LBRA opt_stmt_list.b RBRA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final StmtBlock b = (StmtBlock) _symbol_b.value;
					 return new If(a, b, new Opt());
				}
			},
			new Action() {	// [29] ifStmt = IF LPAR expr.a RPAR LBRA opt_stmt_list.b RBRA ELSE LBRA opt_stmt_list.c RBRA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final StmtBlock b = (StmtBlock) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 10];
					final StmtBlock c = (StmtBlock) _symbol_c.value;
					 return new If(a, b, new Opt(c));
				}
			},
			new Action() {	// [30] id_decl_stmt = INT id_decl.a SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final IdDecl a = (IdDecl) _symbol_a.value;
					  return new IdDeclStmt(a, new Opt());
				}
			},
			new Action() {	// [31] id_decl_stmt = INT id_decl.a ASSIGN expr.b SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final IdDecl a = (IdDecl) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final Expr b = (Expr) _symbol_b.value;
					  return new IdDeclStmt(a, new Opt(b));
				}
			},
			new Action() {	// [32] expr = num_expr.a LE num_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Le(a, b);
				}
			},
			new Action() {	// [33] expr = num_expr.a GE num_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Ge(a, b);
				}
			},
			new Action() {	// [34] expr = num_expr.a LEQ num_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Leq(a, b);
				}
			},
			new Action() {	// [35] expr = num_expr.a GEQ num_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Geq(a, b);
				}
			},
			new Action() {	// [36] expr = num_expr.a NOT num_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Not(a, b);
				}
			},
			new Action() {	// [37] expr = num_expr.a EQUALS num_expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Equals(a, b);
				}
			},
			Action.RETURN,	// [38] expr = num_expr
			new Action() {	// [39] num_expr = num_expr.a ADD term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Add(a, b);
				}
			},
			new Action() {	// [40] num_expr = num_expr.a SUB term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Sub(a, b);
				}
			},
			Action.RETURN,	// [41] num_expr = term
			new Action() {	// [42] term = term.a MOD factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a, b);
				}
			},
			new Action() {	// [43] term = term.a DIV factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a, b);
				}
			},
			new Action() {	// [44] term = term.a MUL factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a, b);
				}
			},
			Action.RETURN,	// [45] term = factor
			Action.RETURN,	// [46] factor = id_use_expr
			Action.RETURN,	// [47] factor = numeral
			new Action() {	// [48] factor = LPAR num_expr.a RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
				}
			},
			Action.RETURN,	// [49] factor = nestedFuncCall
			new Action() {	// [50] id_use_expr = id_use.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUse a = (IdUse) _symbol_a.value;
					 return new IdUseExpr(a);
				}
			},
			new Action() {	// [51] id_use = ID.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new IdUse(a);
				}
			},
			new Action() {	// [52] id_decl = ID.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new IdDecl(a);
				}
			},
			new Action() {	// [53] numeral = NUMERAL.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Numeral(a);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
